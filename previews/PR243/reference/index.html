<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · FrankWolfe.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FrankWolfe.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/1_mathopt_lmo/">Comparison with MathOptInterface on a Probability Simplex</a></li><li><a class="tocitem" href="../examples/2_polynomial_regression/">Polynomial Regression</a></li><li><a class="tocitem" href="../examples/3_matrix_completion/">Matrix Completion</a></li><li><a class="tocitem" href="../examples/4_rational_opt/">Exact Optimization with Rational Arithmetic</a></li><li><a class="tocitem" href="../examples/5_blended_cg/">Blended Conditional Gradients</a></li></ul></li><li class="is-active"><a class="tocitem" href>References</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#LMOs"><span>LMOs</span></a></li><li><a class="tocitem" href="#Functions-and-Structures"><span>Functions and Structures</span></a></li><li class="toplevel"><a class="tocitem" href="#Components"><span>Components</span></a></li><li><a class="tocitem" href="#Active-set-management"><span>Active set management</span></a></li><li><a class="tocitem" href="#Step-size-determination"><span>Step size determination</span></a></li><li><a class="tocitem" href="#Functions-and-Structures-2"><span>Functions and Structures</span></a></li><li><a class="tocitem" href="#Custom-extreme-point-types"><span>Custom extreme point types</span></a></li><li><a class="tocitem" href="#Batch-and-momentum-iterators"><span>Batch and momentum iterators</span></a></li></ul></li><li><a class="tocitem" href="../indexlist/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><p>This section contains all main algorithms of the <a href="https://github.com/ZIB-IOL/FrankWolfe.jl"><code>FrankWolfe.jl</code></a> package. These are the ones typical users will call.</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.frank_wolfe" href="#FrankWolfe.frank_wolfe"><code>FrankWolfe.frank_wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frank_wolfe(f, grad!, lmo, x0; ...)</code></pre><p>Simplest form of the Frank-Wolfe algorithm. Returns a tuple <code>(x, v, primal, dual_gap, traj_data)</code> with:</p><ul><li><code>x</code> final iterate</li><li><code>v</code> last vertex from the LMO</li><li><code>primal</code> primal value <code>f(x)</code></li><li><code>dual_gap</code> final Frank-Wolfe gap</li><li><code>traj_data</code> vector of trajectory information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/fw_algorithms.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.lazified_conditional_gradient" href="#FrankWolfe.lazified_conditional_gradient"><code>FrankWolfe.lazified_conditional_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lazified_conditional_gradient</code></pre><p>Similar to <a href="#FrankWolfe.frank_wolfe"><code>frank_wolfe</code></a> but lazyfying the LMO: each call is stored in a cache, which is looked up first for a good-enough direction. The cache used is a <a href="#FrankWolfe.MultiCacheLMO"><code>FrankWolfe.MultiCacheLMO</code></a> or a <a href="#FrankWolfe.VectorCacheLMO"><code>FrankWolfe.VectorCacheLMO</code></a> depending on whether the provided <code>cache_size</code> option is finite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/fw_algorithms.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.away_frank_wolfe" href="#FrankWolfe.away_frank_wolfe"><code>FrankWolfe.away_frank_wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">away_frank_wolfe</code></pre><p>Frank-Wolfe with away steps. The algorithm maintains the current iterate as a convex combination of vertices in the <a href="#FrankWolfe.ActiveSet"><code>FrankWolfe.ActiveSet</code></a> data structure. See the <a href="https://arxiv.org/abs/2104.06675">paper</a> for illustrations of away steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/afw.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.blended_conditional_gradient" href="#FrankWolfe.blended_conditional_gradient"><code>FrankWolfe.blended_conditional_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blended_conditional_gradient(f, grad!, lmo, x0)</code></pre><p>Entry point for the Blended Conditional Gradient algorithm. See Braun, Gábor, et al. &quot;Blended conditonal gradients&quot; ICML 2019. The method works on an active set like <a href="#FrankWolfe.away_frank_wolfe"><code>FrankWolfe.away_frank_wolfe</code></a>, performing gradient descent over the convex hull of active vertices, removing vertices when their weight drops to 0 and adding new vertices by calling the linear oracle in a lazy fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.stochastic_frank_wolfe" href="#FrankWolfe.stochastic_frank_wolfe"><code>FrankWolfe.stochastic_frank_wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stochastic_frank_wolfe(f::StochasticObjective, lmo, x0; ...)</code></pre><p>Stochastic version of Frank-Wolfe, evaluates the objective and gradient stochastically, implemented through the <a href="@ref">FrankWolfe.StochasticObjective</a> interface.</p><p>Keyword arguments include <code>batch_size</code> to pass a fixed <code>batch_size</code> or a <code>batch_iterator</code> implementing <code>batch_size = FrankWolfe.batchsize_iterate(batch_iterator)</code> for algorithms like Variance-reduced and projection-free stochastic optimization, E Hazan, H Luo, 2016.</p><p>Similarly, a constant <code>momentum</code> can be passed or replaced by a <code>momentum_iterator</code> implementing <code>momentum = FrankWolfe.momentum_iterate(momentum_iterator)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/fw_algorithms.jl#L445-L458">source</a></section></article><h1 id="LMOs"><a class="docs-heading-anchor" href="#LMOs">LMOs</a><a id="LMOs-1"></a><a class="docs-heading-anchor-permalink" href="#LMOs" title="Permalink"></a></h1><p>The Linear Minimization Oracle (LMO) is a key component called at each iteration of the FW algorithm. Given <span>$d\in \mathcal{X}$</span>, it returns a vertex of the feasible set:</p><p class="math-container">\[v\in \argmin_{x\in \mathcal{C}} \langle d,x \rangle.\]</p><p><a href="https://github.com/ZIB-IOL/FrankWolfe.jl"><code>FrankWolfe.jl</code></a> features the following common LMOs out of the box:</p><ul><li>probability simplex: <a href="#FrankWolfe.ProbabilitySimplexOracle"><code>FrankWolfe.ProbabilitySimplexOracle</code></a></li><li>unit simplex: <a href="#FrankWolfe.UnitSimplexOracle"><code>FrankWolfe.UnitSimplexOracle</code></a></li><li><span>$K$</span>-sparse polytope: <a href="#FrankWolfe.KSparseLMO"><code>FrankWolfe.KSparseLMO</code></a></li><li><span>$K$</span>-norm ball: <a href="#FrankWolfe.KNormBallLMO"><code>FrankWolfe.KNormBallLMO</code></a></li><li><span>$L^p$</span>-norm ball: <a href="#FrankWolfe.LpNormLMO"><code>FrankWolfe.LpNormLMO</code></a></li><li>Birkhoff polytope: <a href="#FrankWolfe.BirkhoffPolytopeLMO"><code>FrankWolfe.BirkhoffPolytopeLMO</code></a></li></ul><p>All of them are subtypes of <a href="#FrankWolfe.LinearMinimizationOracle"><code>FrankWolfe.LinearMinimizationOracle</code></a> and implement the following method:</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point" href="#FrankWolfe.compute_extreme_point"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_extreme_point(lmo::LinearMinimizationOracle, direction; kwargs...)</code></pre><p>Computes the point <code>argmin_{v ∈ C} v ⋅ direction</code> with <code>C</code> the set represented by the LMO. All LMOs should accept keyword arguments that they can ignore.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L10-L16">source</a></section></article><h2 id="Functions-and-Structures"><a class="docs-heading-anchor" href="#Functions-and-Structures">Functions and Structures</a><a id="Functions-and-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LinearMinimizationOracle" href="#FrankWolfe.LinearMinimizationOracle"><code>FrankWolfe.LinearMinimizationOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for linear minimization oracles.</p><p>All LMOs must implement <code>compute_extreme_point(lmo::LMO, direction)</code> and return a vector <code>v</code> of the appropriate type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.CachedLinearMinimizationOracle" href="#FrankWolfe.CachedLinearMinimizationOracle"><code>FrankWolfe.CachedLinearMinimizationOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachedLinearMinimizationOracle{LMO}</code></pre><p>Oracle wrapping another one of type lmo. Subtypes of <code>CachedLinearMinimizationOracle</code> contain a cache of previous solutions.</p><p>By convention, the inner oracle is named <code>inner</code>. Cached optimizers are expected to implement <code>Base.empty!</code> and <code>Base.length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.SingleLastCachedLMO" href="#FrankWolfe.SingleLastCachedLMO"><code>FrankWolfe.SingleLastCachedLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleLastCachedLMO{LMO, VT}</code></pre><p>Caches only the last result from an LMO and stores it in <code>last_vertex</code>. Vertices of <code>LMO</code> have to be of type <code>VT</code> if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MultiCacheLMO" href="#FrankWolfe.MultiCacheLMO"><code>FrankWolfe.MultiCacheLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiCacheLMO{N, LMO, VT}</code></pre><p>Cache for a LMO storing up to <code>N</code> vertices in the cache, removed in FIFO style. <code>oldest_idx</code> keeps track of the oldest index in the tuple, i.e. to replace next. <code>VT</code>, if provided, must be the type of vertices returned by <code>LMO</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L78-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.VectorCacheLMO" href="#FrankWolfe.VectorCacheLMO"><code>FrankWolfe.VectorCacheLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorCacheLMO{N, LMO, VT}</code></pre><p>Cache for a LMO storing an unbounded number of vertices of type <code>VT</code> in the cache. <code>VT</code>, if provided, must be the type of vertices returned by <code>LMO</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ProductLMO" href="#FrankWolfe.ProductLMO"><code>FrankWolfe.ProductLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductLMO(lmos...)</code></pre><p>Linear minimization oracle over the Cartesian product of multiple LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.ProductLMO, Tuple}" href="#FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.ProductLMO, Tuple}"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_extreme_point(lmo::ProductLMO, direction::Tuple; kwargs...)</code></pre><p>Extreme point computation on Cartesian product, with a direction <code>(d1, d2, ...)</code> given as a tuple of directions. All keyword arguments are passed to all LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{N}, Tuple{FrankWolfe.ProductLMO{N, TL} where TL&lt;:Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, AbstractArray}} where N" href="#FrankWolfe.compute_extreme_point-Union{Tuple{N}, Tuple{FrankWolfe.ProductLMO{N, TL} where TL&lt;:Tuple{Vararg{FrankWolfe.LinearMinimizationOracle, N}}, AbstractArray}} where N"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_extreme_point(lmo::ProductLMO, direction::AbstractArray; direction_indices, storage=similar(direction))</code></pre><p>Extreme point computation, with a direction array and <code>direction_indices</code> provided such that: <code>direction[direction_indices[i]]</code> is passed to the i-th LMO. The result is stored in the optional <code>storage</code> container.</p><p>All keyword arguments are passed to all LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/oracles.jl#L284-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.UnitSimplexOracle" href="#FrankWolfe.UnitSimplexOracle"><code>FrankWolfe.UnitSimplexOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitSimplexOracle(right_side)</code></pre><p>Represents the scaled unit simplex:</p><pre><code class="nohighlight hljs">C = {x ∈ R^n_+, ∑x ≤ right_side}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/simplex_oracles.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T" href="#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any}} where T"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LMO for scaled unit simplex: <code>∑ x_i = τ</code> Returns either vector of zeros or vector with one active value equal to RHS if there exists an improving direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/simplex_oracles.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T" href="#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.UnitSimplexOracle{T}, Any, Any}} where T"><code>FrankWolfe.compute_dual_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual costs for a given primal solution to form a primal dual pair for scaled unit simplex. Returns two vectors. The first one is the dual costs associated with the constraints  and the second is the reduced costs for the variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/simplex_oracles.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ProbabilitySimplexOracle" href="#FrankWolfe.ProbabilitySimplexOracle"><code>FrankWolfe.ProbabilitySimplexOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProbabilitySimplexOracle(right_side)</code></pre><p>Represents the scaled probability simplex:</p><pre><code class="nohighlight hljs">C = {x ∈ R^n_+, ∑x = right_side}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/simplex_oracles.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T" href="#FrankWolfe.compute_extreme_point-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any}} where T"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LMO for scaled probability simplex. Returns a vector with one active value equal to RHS in the most improving (or least degrading) direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/simplex_oracles.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T" href="#FrankWolfe.compute_dual_solution-Union{Tuple{T}, Tuple{FrankWolfe.ProbabilitySimplexOracle{T}, Any, Any}} where T"><code>FrankWolfe.compute_dual_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual costs for a given primal solution to form a primal dual pair for scaled probability simplex. Returns two vectors. The first one is the dual costs associated with the constraints  and the second is the reduced costs for the variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/simplex_oracles.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.KSparseLMO" href="#FrankWolfe.KSparseLMO"><code>FrankWolfe.KSparseLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KSparseLMO{T}(K::Int, right_hand_side::T)</code></pre><p>LMO for the K-sparse polytope:</p><pre><code class="nohighlight hljs">C = B_1(τK) ∩ B_∞(τ)</code></pre><p>with <code>τ</code> the <code>right_hand_side</code> parameter. The LMO results in a vector with the K largest absolute values of direction, taking values <code>-τ sign(x_i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/polytope_oracles.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.BirkhoffPolytopeLMO" href="#FrankWolfe.BirkhoffPolytopeLMO"><code>FrankWolfe.BirkhoffPolytopeLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BirkhoffPolytopeLMO</code></pre><p>The Birkhoff polytope encodes doubly stochastic matrices. Its extreme vertices are all permutation matrices of side-dimension <code>dimension</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/polytope_oracles.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LpNormLMO" href="#FrankWolfe.LpNormLMO"><code>FrankWolfe.LpNormLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LpNormLMO{T, p}(right_hand_side)</code></pre><p>LMO with feasible set being a bound on the L-p norm:</p><pre><code class="nohighlight hljs">C = {x ∈ R^n, norm(x, p) ≤ right_side}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/norm_oracles.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.KNormBallLMO" href="#FrankWolfe.KNormBallLMO"><code>FrankWolfe.KNormBallLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KNormBallLMO{T}(K::Int, right_hand_side::T)</code></pre><p>LMO for the K-norm ball, intersection of L<em>1-ball (τK) and L</em>∞-ball (τ/K)</p><pre><code class="nohighlight hljs">C_{K,τ} = conv { B_1(τ) ∪ B_∞(τ / K) }</code></pre><p>with <code>τ</code> the <code>right_hand_side</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/norm_oracles.jl#L92-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.NuclearNormLMO" href="#FrankWolfe.NuclearNormLMO"><code>FrankWolfe.NuclearNormLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NuclearNormLMO{T}(δ)</code></pre><p>LMO over matrices that have a nuclear norm less than δ. The LMO returns the rank-one matrix with singular value δ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/norm_oracles.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.NuclearNormLMO, AbstractMatrix{T} where T}" href="#FrankWolfe.compute_extreme_point-Tuple{FrankWolfe.NuclearNormLMO, AbstractMatrix{T} where T}"><code>FrankWolfe.compute_extreme_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Best rank-one approximation using the greatest singular value computed with Arpack.</p><p>Warning: this does not work (yet) with all number types, BigFloat and Float16 fail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/norm_oracles.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MathOptLMO" href="#FrankWolfe.MathOptLMO"><code>FrankWolfe.MathOptLMO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MathOptLMO{OT &lt;: MOI.Optimizer} &lt;: LinearMinimizationOracle</code></pre><p>Linear minimization oracle with feasible space defined through a MathOptInterface.Optimizer. The oracle call sets the direction and reruns the optimizer.</p><p>The <code>direction</code> vector has to be set in the same order of variables as the <code>MOI.ListOfVariableIndices()</code> getter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/moi_oracle.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.convert_mathopt" href="#FrankWolfe.convert_mathopt"><code>FrankWolfe.convert_mathopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_mathopt(lmo::LMO, optimizer::OT; kwargs...) -&gt; MathOptLMO{OT}</code></pre><p>Converts the given LMO to its equivalent MathOptInterface representation using <code>optimizer</code>. Must be implemented by LMOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/moi_oracle.jl#L50-L55">source</a></section></article><h1 id="Components"><a class="docs-heading-anchor" href="#Components">Components</a><a id="Components-1"></a><a class="docs-heading-anchor-permalink" href="#Components" title="Permalink"></a></h1><p>This section gathers all additional relevant components of the package.</p><h2 id="Active-set-management"><a class="docs-heading-anchor" href="#Active-set-management">Active set management</a><a id="Active-set-management-1"></a><a class="docs-heading-anchor-permalink" href="#Active-set-management" title="Permalink"></a></h2><p>The active set represents an iterate as a convex combination of atoms. It maintains a vector of atoms, the corresponding weights, and the current iterate.</p><pre><code class="language- hljs">Module = [FrankWolfe]
Pages = [active_set.jl]</code></pre><h2 id="Step-size-determination"><a class="docs-heading-anchor" href="#Step-size-determination">Step size determination</a><a id="Step-size-determination-1"></a><a class="docs-heading-anchor-permalink" href="#Step-size-determination" title="Permalink"></a></h2><p>For all Frank-Wolfe algorithms, a step size must be determined to move from the current iterate to the next one. This step size can be determined by exact line search or any other rule represented by a subtype of <code>LineSearchMethod</code> which must implement <code>line_search_wrapper</code>.</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.line_search_wrapper" href="#FrankWolfe.line_search_wrapper"><code>FrankWolfe.line_search_wrapper</code></a> — <span class="docstring-category">Function</span></header><section><div><p>line search wrapper NOTE: The stepsize is defined as x - gamma * d</p><p>Returns the step size gamma and the Lipschitz estimate L</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.LineSearchMethod" href="#FrankWolfe.LineSearchMethod"><code>FrankWolfe.LineSearchMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Line search method to apply once the direction is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/defs.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.adaptive_step_size" href="#FrankWolfe.adaptive_step_size"><code>FrankWolfe.adaptive_step_size</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Slight modification of Adaptive Step Size strategy from https://arxiv.org/pdf/1806.05123.pdf</p><p>Note: direction is opposite to the improving direction norm(gradient, direction) &gt; 0 TODO: </p><ul><li>make emphasis aware and optimize</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MonotonousStepSize" href="#FrankWolfe.MonotonousStepSize"><code>FrankWolfe.MonotonousStepSize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonotonousStepSize{F}</code></pre><p>Represents a monotonous open-loop step size. Contains a halving factor <code>N</code> increased at each iteration until there is primal progress <code>gamma = 2 / (t + 2) * 2^(-N)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L781-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.MonotonousNonConvexStepSize" href="#FrankWolfe.MonotonousNonConvexStepSize"><code>FrankWolfe.MonotonousNonConvexStepSize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonotonousNonConvexStepSize{F}</code></pre><p>Represents a monotonous open-loop non-convex step size. Contains a halving factor <code>N</code> increased at each iteration until there is primal progress <code>gamma = 1 / sqrt(t + 1) * 2^(-N)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L824-L830">source</a></section></article><h2 id="Functions-and-Structures-2"><a class="docs-heading-anchor" href="#Functions-and-Structures-2">Functions and Structures</a><a class="docs-heading-anchor-permalink" href="#Functions-and-Structures-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ActiveSet" href="#FrankWolfe.ActiveSet"><code>FrankWolfe.ActiveSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ActiveSet{AT, R, IT}</code></pre><p>Represents an active set of extreme vertices collected in a FW algorithm, along with their coefficients <code>(λ_i, a_i)</code>. <code>R</code> is the type of the <code>λ_i</code>, <code>AT</code> is the type of the atoms <code>a_i</code>. The iterate <code>x = ∑λ_i a_i</code> is stored in x with type <code>IT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/active_set.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_update!" href="#FrankWolfe.active_set_update!"><code>FrankWolfe.active_set_update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_set_update!(active_set::ActiveSet, lambda, atom)</code></pre><p>Adds the atom to the active set with weight lambda or adds lambda to existing atom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/active_set.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_active_set_iterate" href="#FrankWolfe.compute_active_set_iterate"><code>FrankWolfe.compute_active_set_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_active_set_iterate(active_set)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/active_set.jl#L124-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_argmin" href="#FrankWolfe.active_set_argmin"><code>FrankWolfe.active_set_argmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_set_argmin(active_set::ActiveSet, direction)</code></pre><p>Computes the linear minimizer in the direction on the active set. Returns <code>(λ_i, a_i, i)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/active_set.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.active_set_argminmax" href="#FrankWolfe.active_set_argminmax"><code>FrankWolfe.active_set_argminmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_set_argminmax(active_set::ActiveSet, direction)</code></pre><p>Computes the linear minimizer in the direction on the active set. Returns <code>(λ_min, a_min, i_min, λ_max, a_max, i_max)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/active_set.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.find_minmax_directions" href="#FrankWolfe.find_minmax_directions"><code>FrankWolfe.find_minmax_directions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_minmax_directions(active_set::ActiveSet, direction, Φ)</code></pre><p>Computes the point of the active set minimizing in <code>direction</code> on the active set (local Frank Wolfe) and the maximizing one (away step). Returns the two corresponding indices in the active set, along with a flag indicating if the direction improvement is above a threshold. <code>goodstep_tolerance ∈ (0, 1]</code> is a tolerance coefficient multiplying Φ for the validation of the progress. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/active_set.jl#L203-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.minimize_over_convex_hull!" href="#FrankWolfe.minimize_over_convex_hull!"><code>FrankWolfe.minimize_over_convex_hull!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimize_over_convex_hull!</code></pre><p>Given a function f with gradient grad! and an active set active_set this function will minimize the function over the convex hull of the active set until the strong-wolfe gap over the active set is below tolerance.</p><p>It will either directly minimize over the convex hull using simplex gradient descent, or it will transform the problem to barycentric coordinates and minimize over the unit probability simplex using gradient descent or Nesterov&#39;s accelerated gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L297-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}" href="#FrankWolfe.build_reduced_problem-Tuple{AbstractVector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:FrankWolfe.ScaledHotVector, Any, Any, Any, Any}"><code>FrankWolfe.build_reduced_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_reduced_problem(atoms::AbstractVector{&lt;:AbstractVector}, hessian, weights, gradient, tolerance)</code></pre><p>Given an active set formed by vectors , a (constant) Hessian and a gradient constructs a quadratic problem over the unit probability simplex that is equivalent to minimizing the original function over the convex hull of the active set. If λ are the barycentric coordinates of dimension equal to the cardinality of the active set, the objective function is:     f(λ) = reduced<em>linear^T λ + 0.5 * λ^T reduced</em>hessian λ</p><p>In the case where we find that the current iterate has a strong-Wolfe gap over the convex hull of the active set that is below the tolerance we return nothing (as there is nothing to do).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L445-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.strong_frankwolfe_gap" href="#FrankWolfe.strong_frankwolfe_gap"><code>FrankWolfe.strong_frankwolfe_gap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Checks the strong Frank-Wolfe gap for the reduced problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L541-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex" href="#FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex"><code>FrankWolfe.accelerated_simplex_gradient_descent_over_probability_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accelerated_simplex_gradient_descent_over_probability_simplex</code></pre><p>Minimizes an objective function over the unit probability simplex until the Strong-Wolfe gap is below tolerance using Nesterov&#39;s accelerated gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L559-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.simplex_gradient_descent_over_probability_simplex" href="#FrankWolfe.simplex_gradient_descent_over_probability_simplex"><code>FrankWolfe.simplex_gradient_descent_over_probability_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplex_gradient_descent_over_probability_simplex</code></pre><p>Minimizes an objective function over the unit probability simplex until the Strong-Wolfe gap is below tolerance using gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L661-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.projection_simplex_sort" href="#FrankWolfe.projection_simplex_sort"><code>FrankWolfe.projection_simplex_sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">projection_simplex_sort(x; s=1.0)</code></pre><p>Perform a projection onto the probability simplex of radius <code>s</code> using a sorting algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L743-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.strong_frankwolfe_gap_probability_simplex" href="#FrankWolfe.strong_frankwolfe_gap_probability_simplex"><code>FrankWolfe.strong_frankwolfe_gap_probability_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strong_frankwolfe_gap_probability_simplex</code></pre><p>Compute the Strong-Wolfe gap over the unit probability simplex given a gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L763-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.simplex_gradient_descent_over_convex_hull" href="#FrankWolfe.simplex_gradient_descent_over_convex_hull"><code>FrankWolfe.simplex_gradient_descent_over_convex_hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplex_gradient_descent_over_convex_hull(f, grad!, gradient, active_set, tolerance, t, time_start, non_simplex_iter)</code></pre><p>Minimizes an objective function over the convex hull of the active set until the Strong-Wolfe gap is below tolerance using simplex gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L787-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.lp_separation_oracle" href="#FrankWolfe.lp_separation_oracle"><code>FrankWolfe.lp_separation_oracle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns either a tuple <code>(y, val)</code> with <code>y</code> an atom from the active set satisfying the progress criterion and <code>val</code> the corresponding gap <code>dot(y, direction)</code> or the same tuple with <code>y</code> from the LMO.</p><p><code>inplace_loop</code> controls whether the iterate type allows in-place writes. <code>kwargs</code> are passed on to the LMO oracle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/blended_cg.jl#L977-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.Emphasis" href="#FrankWolfe.Emphasis"><code>FrankWolfe.Emphasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Emphasis given to the algorithm for memory-saving or not. The memory-saving mode may not be faster than the default blas mode for small dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/defs.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ObjectiveFunction" href="#FrankWolfe.ObjectiveFunction"><code>FrankWolfe.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveFunction</code></pre><p>Represents an objective function optimized by algorithms. Subtypes of <code>ObjectiveFunction</code> must implement at least</p><ul><li><code>compute_value(::ObjectiveFunction, x)</code> for primal value evaluation</li><li><code>compute_gradient(::ObjectiveFunction, x)</code> for gradient evaluation.</li></ul><p>and optionally <code>compute_value_gradient(::ObjectiveFunction, x)</code> returning the (primal, gradient) pair. <code>compute_gradient</code> may always use the same storage and return a reference to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/function_gradient.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.compute_value_gradient" href="#FrankWolfe.compute_value_gradient"><code>FrankWolfe.compute_value_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_value_gradient(f::ObjectiveFunction, x; [kwargs...])</code></pre><p>Computes in one call the pair <code>(value, gradient)</code> evaluated at <code>x</code>. By default, calls <code>compute_value</code> and <code>compute_gradient</code> with keywords <code>kwargs</code> passed down to both.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/function_gradient.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.StochasticObjective" href="#FrankWolfe.StochasticObjective"><code>FrankWolfe.StochasticObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochasticObjective{F, G, XT, S}(f::F, grad!::G, xs::XT, storage::S)</code></pre><p>Represents a composite function evaluated with stochastic gradient. <code>f(θ, x)</code> evaluates the loss for a single data point <code>x</code> and parameter <code>θ</code>. <code>grad!(storage, θ, x)</code> adds to storage the partial gradient with respect to data point <code>x</code> at parameter <code>θ</code>. <code>xs</code> must be an indexable iterable (<code>Vector{Vector{Float64}}</code> for instance). Functions using a <code>StochasticObjective</code> have optional keyword arguments <code>rng</code>, <code>batch_size</code> and <code>full_evaluation</code> controlling whether the function should be evaluated over all data points.</p><p>Note: <code>grad!</code> must <strong>not</strong> reset the storage to 0 before adding to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/function_gradient.jl#L57-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.plot_results" href="#FrankWolfe.plot_results"><code>FrankWolfe.plot_results</code></a> — <span class="docstring-category">Function</span></header><section><div><p>plot_results</p><p>Given a series of list, generate subplots. list<em>data</em>y -&gt; contains a list of a list of lists (where each list refers to a subplot, and a list of lists refers to the y-values of the series inside a subplot). list<em>data</em>x -&gt; contains a list of a list of lists (where each list refers to a subplot, and a list of lists refers to the x-values of the series inside a subplot). So if we have one plot with two series, these might look like:     list<em>data</em>y = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]     list<em>data</em>x = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]</p><p>And if we have two plots, each with two series, these might look like:     list<em>data</em>y = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11, 12], [7, 8, 9, 10, 11, 12]]]     list<em>data</em>x = [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11, 12], [7, 8, 9, 10, 11, 12]]]</p><p>list<em>label -&gt; contains the labels for the series that will be plotted, which has to have a length equal to the number of series that are being plotted:     list</em>label = [&quot;Series 1&quot;, &quot;Series 2&quot;]</p><p>list<em>axis</em>x -&gt; contains the labels for the x-axis that will be plotted,  which has to have a length equal to the number of subplots:      list<em>axis</em>x = [&quot;x-axis plot 1&quot;, &quot;x-axis plot 1&quot;]</p><p>list<em>axis</em>y -&gt; Same as list<em>axis</em>x but for the y-axis</p><p>xscalelog -&gt; A list of values indicating the type of axes to use in each subplot, must be equal to the number of subplots:     xscalelog = [:log, :identity]</p><p>yscalelog -&gt; Same as xscalelog but for the y-axis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L247-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.check_gradients" href="#FrankWolfe.check_gradients"><code>FrankWolfe.check_gradients</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if the gradient using finite differences matches the grad! provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L751-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.trajectory_callback" href="#FrankWolfe.trajectory_callback"><code>FrankWolfe.trajectory_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trajectory_callback(storage)</code></pre><p>Callback pushing the state at each iteration to the passed storage. The state data is only the 5 first fields, usually: <code>(t,primal,dual,dual_gap,time)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L765-L771">source</a></section></article><p>A note on iterates precision in algorithms depending on an active set:   The weights in the active set are currently defined as <code>Float64</code> in the algorithm. This means that even with vertices using a lower precision, the iterate <code>sum_i(lambda_i * v_i)</code> will be upcast to <code>Float64</code>. One reason for keeping this as-is for now is the higher precision required by the computation of iterates from their barycentric decomposition.</p><h2 id="Custom-extreme-point-types"><a class="docs-heading-anchor" href="#Custom-extreme-point-types">Custom extreme point types</a><a id="Custom-extreme-point-types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-extreme-point-types" title="Permalink"></a></h2><p>For some feasible sets, the extreme points of the feasible set returned by the LMO possess a specific structure that can be represented in an efficient manner both for storage and for common operations like scaling and addition with an iterate. They are presented below:</p><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ScaledHotVector" href="#FrankWolfe.ScaledHotVector"><code>FrankWolfe.ScaledHotVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledHotVector{T}</code></pre><p>Represents a vector of at most one value different from 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.RankOneMatrix" href="#FrankWolfe.RankOneMatrix"><code>FrankWolfe.RankOneMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RankOneMatrix{T, UT, VT}</code></pre><p>Represents a rank-one matrix <code>R = u * vt&#39;</code>. Composes like a charm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/types.jl#L89-L94">source</a></section></article><h2 id="Batch-and-momentum-iterators"><a class="docs-heading-anchor" href="#Batch-and-momentum-iterators">Batch and momentum iterators</a><a id="Batch-and-momentum-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-and-momentum-iterators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.momentum_iterate" href="#FrankWolfe.momentum_iterate"><code>FrankWolfe.momentum_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">momentum_iterate(iter::MomentumIterator) -&gt; ρ</code></pre><p>Method to implement for a type <code>MomentumIterator</code>. Returns the next momentum value <code>ρ</code> and updates the iterator internal state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L899-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ExpMomentumIterator" href="#FrankWolfe.ExpMomentumIterator"><code>FrankWolfe.ExpMomentumIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExpMomentumIterator{T}</code></pre><p>Iterator for the momentum used in the variant of Stochastic Frank-Wolfe. Momentum coefficients are the values of the iterator: <code>ρ_t = 1 - num / (offset + t)^exp</code></p><p>The state corresponds to the iteration count.</p><p>Source: Stochastic Conditional Gradient Methods: From Convex Minimization to Submodular Maximization Aryan Mokhtari, Hamed Hassani, Amin Karbasi, JMLR 2020.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L907-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ConstantMomentumIterator" href="#FrankWolfe.ConstantMomentumIterator"><code>FrankWolfe.ConstantMomentumIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantMomentumIterator{T}</code></pre><p>Iterator for momentum with a fixed damping value, always return the value and a dummy state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L934-L938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.batchsize_iterate" href="#FrankWolfe.batchsize_iterate"><code>FrankWolfe.batchsize_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batchsize_iterate(iter::BatchSizeIterator) -&gt; b</code></pre><p>Method to implement for a batch size iterator of type <code>BatchSizeIterator</code>. Calling <code>batchsize_iterate</code> returns the next batch size and typically update the internal state of <code>iter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L947-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.ConstantBatchIterator" href="#FrankWolfe.ConstantBatchIterator"><code>FrankWolfe.ConstantBatchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantBatchIterator(batch_size)</code></pre><p>Batch iterator always returning a constant batch size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L955-L959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FrankWolfe.IncrementBatchIterator" href="#FrankWolfe.IncrementBatchIterator"><code>FrankWolfe.IncrementBatchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IncrementBatchIterator(starting_batch_size, max_batch_size, [increment = 1])</code></pre><p>Batch size starting at starting<em>batch</em>size and incrementing by <code>increment</code> at every iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/FrankWolfe.jl/blob/94904009f00e16cd223ec551a876572306af5472/src/utils.jl#L966-L970">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/5_blended_cg/">« Blended Conditional Gradients</a><a class="docs-footer-nextpage" href="../indexlist/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Tuesday 28 September 2021 12:39">Tuesday 28 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
